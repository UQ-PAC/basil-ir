chapter \<open>Generated by Lem from \<open>test.lem\<close>.\<close>

theory "Test" 

imports
  Main
  "LEM.Lem_bool"
  "LEM.Lem_num"
  "LEM.Lem_list"
  "LEM.Lem_set"
  "LEM.Lem_set_extra"
  "LEM.Lem_map"
  "LEM.Lem_map_extra"
  "LEM.Lem_basic_classes"
  "LEM.Lem_maybe"
  "LEM.Lem_assert_extra"

begin 



\<comment> \<open>\<open>open import Bool Num List Set Set_extra Map Map_extra Basic_classes Maybe Assert_extra\<close>\<close>

datatype btype = 
  BitvecType " int "
  | BoolType

datatype BVOp = 
  BVADD
  | BVAND
  | BVOR
  | BVXOR
  | BVSDIV
  | BVUDIV
  | BVSREM
  | BVUREM
  | BVSMOD
  | BVMUL
  | BVASHR
  | BVLSHR
  | BVSHL

datatype expr = bvexpr | boolexpr

datatype bvexpr = 
    BVConstant " int " " int "
  | BinExpr " BVOp " " int " " bvexpr " " bvexpr "
  | BVNot " int " " bvexpr "
  | BVNeg " int " " bvexpr "
  | BVVar " int " " string " 
  | Extend " int " "  bvexpr " 
  | BVFApply " string " " expr list " " int "


datatype boolexpr = 
  BoolConstant " bool "
  | BVCOMP " bvexpr " " bvexpr "
  | BVULT " bvexpr " " bvexpr "
  | BVSLT " bvexpr " " bvexpr "
  | BVEQ " bvexpr " " bvexpr "
  | BoolEQ " boolexpr " " boolexpr "
  | BoolAND " boolexpr " " boolexpr "
  | BoolOR " boolexpr " " boolexpr "
  | BoolNOT " boolexpr "
  | BoolVar " string " 
  | BoolFApply " string " " expr list "

fun evalbool  :: \<open> boolexpr \<Rightarrow> bool \<close>  where 
     \<open> evalbool ((BoolConstant b)::boolexpr) = ( b )\<close> 
  for  "b"  :: " bool "
|\<open> evalbool ((BVCOMP e1 e2)::boolexpr) = ( e1 \<noteq> e2 )\<close> 
  for  "e1"  :: " bvexpr " 
  and  "e2"  :: " bvexpr "
|\<open> evalbool (_::boolexpr) = ( False )\<close>


type_synonym ident =" string "

datatype endian = 
  LittleEndian
  | BigEndian

datatype stmt = 
    Decl " btype "
  | BoolDefAssign " ident " " boolexpr "
  | BVDefAssign " ident " " int " " bvexpr "
  | Store " ident " " ident " " bvexpr " " bvexpr "
  | Load " ident " " ident " " bvexpr " " int "
  | Call " ident " " expr list "
  | PureCallAssign " ident " " ident " " expr list "

datatype blockterm = 
  Goto " ident list " 
  | Stop
  | Unreachable

record block = 
 
  block_label::" ident " 

  stmts::" stmt list " 

  terminator::" blockterm " 



record proc = 

  proc_label::" ident " 

  entry_block::" ident " 

  blocks::" (ident, block) Map.map "





fun outgoing  :: \<open> blockterm \<Rightarrow>(ident)list \<close>  where 
     \<open> outgoing ((Goto is1):: blockterm) = ( is1 )\<close> 
  for  "is1"  :: "(ident)list "
|\<open> outgoing (_:: blockterm) = ( [])\<close>


definition incoming  :: \<open> proc \<Rightarrow>((string),((string)set))Map.map \<close>  where 
     \<open> incoming (p:: proc) = (
  (let outgoing1 = (Set.image ((\<lambda> a .  (a, List.set (outgoing(terminator   a))))) (Map.ran(blocks   p))) in  
  (let get_incoming_for = ((\<lambda> (i:: ident) .  Set.image
                                                       ( (\<lambda>x .  
                                                         (case  x of
                                                             (b, og) =>
                                                         (block_label   b)
                                                         )))
                                                       (set_filter
                                                          ( (\<lambda>x .  
                                                            (case  x of
                                                                (b, og) => 
                                                            (\<in>) i 
                                                            og
                                                            ))) outgoing1))) in
  (let bids :: ident set = (Map.dom (blocks   p)) in
  (let x = (Lem_map_extra.fromSet ((\<lambda> x .  get_incoming_for x)) bids) in
  x)))))\<close> 
  for  "p"  :: " proc "


fun Option_get  :: \<open> 'a option \<Rightarrow> 'a \<close>  where 
     \<open> Option_get ((Some y)::  'a option) = ( y )\<close> 
  for  "y"  :: " 'a "
|\<open> Option_get (None::  'a option) = ( failwith (''Unsafe maybe get''))\<close>



\<comment> \<open>\<open> two val boolean lattice \<close>\<close>

definition bool_bottom  :: \<open> bool \<close>  where 
     \<open> bool_bottom = ( False )\<close>

definition bool_xf  :: \<open> bool \<Rightarrow> stmt \<Rightarrow> bool \<close>  where 
     \<open> bool_xf (i:: bool) (s::stmt) = ( False )\<close> 
  for  "i"  :: " bool " 
  and  "s"  :: " stmt "

definition bool_join  :: \<open> bool \<Rightarrow> bool \<Rightarrow> bool \<close>  where 
     \<open> bool_join (l::bool) (r::bool) = ( l \<or> r )\<close> 
  for  "l"  :: " bool " 
  and  "r"  :: " bool "


function (sequential,domintros)  worklist_solver  :: \<open> proc \<Rightarrow>(ident)list \<Rightarrow>('a \<Rightarrow> stmt \<Rightarrow> 'a)\<Rightarrow>('a \<Rightarrow> 'a \<Rightarrow> 'a)\<Rightarrow>((ident),'a)Map.map \<Rightarrow> 'a \<Rightarrow>((ident),((ident)set))Map.map \<Rightarrow>((ident),'a)Map.map \<close>  where 
     \<open> worklist_solver (p::proc) ((h # worklist):: ident list) (xf:: 'a \<Rightarrow> stmt \<Rightarrow> 'a) (join :: 'a \<Rightarrow> 'a \<Rightarrow> 'a) (res:: (ident, 'a) Map.map) (bottom:: 'a) (incoming1:: (ident, ( ident set)) Map.map) = ( 
  (let getExisting = ((\<lambda> i .  (case  ( res i) of
                                            Some x => x
                                        | None => bottom
                                      ))) in
  (let base :: 'a = (getExisting h) in
  (let bl = (Option_get ( (blocks   p) h)) in
  (let xfed :: 'a = (List.foldl xf base (stmts   bl)) in
  (let nres = (map_update h xfed res) in
  (let indeps = (list_of_set (Option_get ( incoming1 h))) in
  (let indeps = (List.map getExisting indeps) in
  (let xfed = ((case  indeps of
                     [] => xfed
                 | indeps => List.foldl join xfed indeps
               )) in
  (let worklist = (
                  if (xfed \<noteq> base) then
                    ((outgoing (terminator   bl)) @ worklist) else worklist) in
  worklist_solver p worklist xf join res bottom incoming1))))))))) )\<close> 
  for  "p"  :: " proc " 
  and  "h"  :: " string " 
  and  "worklist"  :: "(string)list " 
  and  "xf"  :: " 'a \<Rightarrow> stmt \<Rightarrow> 'a " 
  and  "join"  :: " 'a \<Rightarrow> 'a \<Rightarrow> 'a " 
  and  "res"  :: "((ident),'a)Map.map " 
  and  "bottom"  :: " 'a " 
  and  "incoming1"  :: "((ident),((ident)set))Map.map "
|\<open> worklist_solver (p::proc) (([]):: ident list) (xf:: 'a \<Rightarrow> stmt \<Rightarrow> 'a) (join :: 'a \<Rightarrow> 'a \<Rightarrow> 'a) (res:: (ident, 'a) Map.map) (bottom:: 'a) (incoming1:: (ident, ( ident set)) Map.map) = ( res )\<close> 
  for  "p"  :: " proc " 
  and  "xf"  :: " 'a \<Rightarrow> stmt \<Rightarrow> 'a " 
  and  "join"  :: " 'a \<Rightarrow> 'a \<Rightarrow> 'a " 
  and  "res"  :: "((ident),'a)Map.map " 
  and  "bottom"  :: " 'a " 
  and  "incoming1"  :: "((ident),((ident)set))Map.map " 
by pat_completeness auto


definition wl_init  :: \<open> proc \<Rightarrow>('a \<Rightarrow> stmt \<Rightarrow> 'a)\<Rightarrow>('a \<Rightarrow> 'a \<Rightarrow> 'a)\<Rightarrow> 'a \<Rightarrow>((ident),'a)Map.map \<close>  where 
     \<open> wl_init (p::proc) (xf:: 'a \<Rightarrow> stmt \<Rightarrow> 'a) (join :: 'a \<Rightarrow> 'a \<Rightarrow> 'a) (bottom:: 'a) = ( 
  (let worklist = (list_of_set (Map.dom(blocks   p))) in
  worklist_solver p worklist xf join Map.empty bottom (incoming p)))\<close> 
  for  "p"  :: " proc " 
  and  "xf"  :: " 'a \<Rightarrow> stmt \<Rightarrow> 'a " 
  and  "join"  :: " 'a \<Rightarrow> 'a \<Rightarrow> 'a " 
  and  "bottom"  :: " 'a "

end
